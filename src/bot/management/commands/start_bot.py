import logging
import os
import random
import re
import traceback
from datetime import datetime, timedelta
from datetime import timezone as dt_timezone
from difflib import get_close_matches
from zoneinfo import ZoneInfo

import aiohttp
import pytz
import telegram
from apscheduler.jobstores.base import JobLookupError
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from asgiref.sync import sync_to_async
from django.core.management.base import BaseCommand
from django.db.models import Avg, F
from django.utils import timezone
from dotenv import load_dotenv
from telegram import (
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    Update,
)
from telegram.ext import (
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from bot.management.core.bot_constants import (
    BotAchievementsCfg,
    BotMessages,
    SiteCfg,
)
from bot.management.core.bot_instance import get_bot_application
from bot.management.core.currency_utils import (
    fetch_currency_rates,
    get_currency_changes,
    save_currency_rates,
)
from bot.management.core.experience import calculate_experience, get_level_info
from bot.management.core.statistics import (
    get_daily_statistics,
    get_daily_statistics_message,
    has_any_trips_on_date,
    update_daily_statistics,
)
from bot.management.core.utils import create_progress_bar
from bot.models import (
    Achievement,
    Company,
    CurrencyRate,
    DailytTips,
    LevelTitle,
    Season,
    SeasonRank,
    UserActivity,
)

logger = logging.getLogger(__name__)

load_dotenv()

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)

JOIN_CO, SELECT_CO = range(2)

VALID_COMPANY_NAME_PATTERN = re.compile(r"^[–ê-–Ø–∞-—è–Å—ëA-Za-z0-9\s\-]+$")


scheduler = AsyncIOScheduler(timezone=ZoneInfo("Europe/Moscow"))


async def help(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.
    """
    help_text = SiteCfg.HELP_TEXT
    await update.message.reply_text(help_text, parse_mode="Markdown")


async def site(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∞–π—Ç–µ"""
    site_info = SiteCfg.MSG_SITE
    await update.message.reply_text(site_info, parse_mode="Markdown")


async def check_achievements(
    user_id: int,
    username: str,
    activity: UserActivity,
    context: ContextTypes.DEFAULT_TYPE
) -> None:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –≤—ã–¥–∞—á–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π —Å
    –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–∞–ø—Ä–æ—Å–∞–º–∏ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
    try:
        today = timezone.now().date()
        join_time = timezone.localtime(activity.join_time)
        leave_time = timezone.localtime(activity.leave_time)
        duration = (leave_time - join_time).total_seconds()
        new_achievements = []
        formatted_achievements = []

        user_stats = await sync_to_async(
            lambda: {
                "company_visits": UserActivity.objects.filter(
                    user_id=user_id,
                    company=activity.company
                ).count(),

                "same_day_users": UserActivity.objects.filter(
                    company=activity.company,
                    join_time__date=join_time.date()
                ).values("user_id").distinct().count(),

                "same_company_today": UserActivity.objects.filter(
                    user_id=user_id,
                    company=activity.company,
                    join_time__date=today
                ).count(),


                "today_trips": UserActivity.objects.filter(
                    user_id=user_id,
                    join_time__date=today
                ).count(),


                "weekly_trips": UserActivity.objects.filter(
                    user_id=user_id,
                    join_time__gte=today - timedelta(days=today.weekday())
                ).count(),


                "avg_duration": UserActivity.objects.filter(
                    user_id=user_id).annotate(
                        duration=F(
                            "leave_time") - F("join_time")).aggregate(
                                avg=Avg("duration"))["avg"]
            }
        )()

        if user_stats["company_visits"] == 1:
            first_visit_achievements = [
                "üèïÔ∏è –Ø –∑–¥–µ—Å—å –≤–ø–µ—Ä–≤—ã–µ, –ø—Ä–∞–≤–¥–∞ –∂–µ?",
                "üå± –ü–µ—Ä–≤—ã–π –≤–∏–∑–∏—Ç –≤ –∫–æ–º–ø–∞–Ω–∏—é!",
                "üë£ –°–ª–µ–¥—ã –ø–µ—Ä–≤–æ–≥–æ –ø–æ—Å–µ—â–µ–Ω–∏—è",
                "üéØ –î–µ–±—é—Ç –≤ –∫–æ–º–ø–∞–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–ª—Å—è!",
                "üÜï –ù–æ–≤–µ–Ω—å–∫–∏–π –≤ —ç—Ç–∏—Ö –∫—Ä–∞—è—Ö",
                "üö© –ü–µ—Ä–≤–∞—è –≤—ã–ª–∞–∑–∫–∞ –≤ –¥–∞–Ω–Ω—É—é –ª–æ–∫–∞—Ü–∏—é",
                "üìå –¢–æ—á–∫–∞ –æ—Ç—Å—á–µ—Ç–∞ –º–æ–µ–≥–æ –ø—É—Ç–∏ –∑–¥–µ—Å—å"]
            new_achievements.append(random.choice(first_visit_achievements))

        if user_stats["same_company_today"] > 1:
            revisit_achievements = [
                "üîÑ –î–µ–∂–∞–≤—é: –°–Ω–æ–≤–∞ –∑–¥–µ—Å—å!",
                "‚ôªÔ∏è –≠–∫–æ–Ω–æ–º–ª—é –Ω–∞ –ø—Ä–æ–ø—É—Å–∫–µ",
                "üìå –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –¥–Ω—è",
                "üèÉ –†–µ–≤–µ—Ä—Å-—Ä–∞—É–Ω–¥: –¢—É–¥–∞ –∏ –æ–±—Ä–∞—Ç–Ω–æ",
                "üîÑ –ü–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ - –º–∞—Ç—å —É—á–µ–Ω–∏—è"
            ]
            new_achievements.append(random.choice(revisit_achievements))

        if user_stats["same_day_users"] >= 2:
            new_achievements.append("üë• –ö–æ–º–∞–Ω–¥–Ω—ã–π –∏–≥—Ä–æ–∫")

        if user_stats["today_trips"] > 3:
            new_achievements.append("üîÅ –ê –º–æ–∂–Ω–æ –º–Ω–µ –µ—â—ë –≤—ã–µ–∑–¥?")

        if user_stats["weekly_trips"] > 16:
            new_achievements.append("üèÜ –õ—É—á—à–∏–π —Å–æ—Ç—Ä—É–¥–Ω–∏–∫")

        weekday = join_time.weekday()
        if weekday in [5, 6]:
            day_name = "—Å—É–±–±–æ—Ç—É" if weekday == 5 else "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"
            new_achievements.append(
                f"üìÖ –Ø –ª—é–±–ª—é —Å–≤–æ—é —Ä–∞–±–æ—Ç—É, —è –ø—Ä–∏–¥—É —Å—é–¥–∞ –≤ {day_name}")
        if 18 <= join_time.hour < 24:
            night_achievements = [
                "üåö –ù–æ—á–Ω–∞—è —Å–º–µ–Ω–∞? –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –∑–∞–±—ã–ª —É–π—Ç–∏?",
                "ü¶á –ë—ç—Ç–º–µ–Ω –±—ã –ø–æ–∑–∞–≤–∏–¥–æ–≤–∞–ª –º–æ–µ–º—É –≥—Ä–∞—Ñ–∏–∫—É",
                "‚òï –ö–æ—Ñ–µ–∏–Ω–æ–≤–∞—è –∫–∞–ø–µ–ª—å–Ω–∏—Ü–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞",
                "üåô '–£—Ç—Ä–æ –≤–µ—á–µ—Ä–∞ –º—É–¥—Ä–µ–Ω–µ–µ' ‚Äî –∞ —è –µ—â—ë —Ç—É—Ç",
                "üåÉ –ù–æ—á–Ω–æ–π –¥–æ—Å–º–æ—Ç—Ä",
                "üåô –°–æ–≤–∞ –∫–æ–º–ø–∞–Ω–∏–∏",
                "ü¶â –ü–æ–ª—É–Ω–æ—á–Ω—ã–π –∞–¥–º–∏–Ω",
                "üåå –õ—É–Ω–∞—Ç–∏–∫"
            ]
            new_achievements.append(random.choice(night_achievements))

        if 0 <= join_time.hour < 9:
            morning_achievements = [
                "‚è∞ –ü—Ä–æ—Å–Ω—É–ª—Å—è —Ä–∞–Ω—å—à–µ –±—É–¥–∏–ª—å–Ω–∏–∫–∞... —Ö–∞-—Ö–∞, —à—É—Ç–∫–∞",
                "üí§ '–Ø –±–æ–¥—Ä!' *—Å–ø–∏—Ç*",
                "üåö –ù–æ—á—å. –£–ª–∏—Ü–∞. –§–æ–Ω–∞—Ä—å. –°–µ—Ä–≤–µ—Ä.",
                "‚òï –ö–æ—Ñ–µ? –ï—â—ë –∫–æ—Ñ–µ! –ò –ª–∞–º–ø–æ—á–∫—É –≤ –∑—É–±—ã...",
                "üìâ –ú–æ–π –º–æ–∑–≥ —Å–µ–π—á–∞—Å –≤ beta-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏",
                "‚òï –ö–æ—Ñ–µ–∏–Ω–æ–≤—ã–π –º–∞—Ä–∞—Ñ–æ–Ω–µ—Ü",
                "üåá –ü–µ—Ä–≤—ã–π –ª—É—á –∏ –Ω–∞ —Ä–∞–±–æ—Ç–µ"
            ]
            new_achievements.append(random.choice(morning_achievements))

        duration_achievements = BotAchievementsCfg.DURATION_ACHIEVEMENTS

        for (min_val, max_val), achievements in duration_achievements.items():
            if min_val <= duration < max_val and achievements:
                new_achievements.append(random.choice(achievements))
                break

        if (user_stats["avg_duration"] and user_stats[
                "avg_duration"].total_seconds() > 9000):
            new_achievements.append("üê¢ –ü–æ—Å–ø–µ—à–∏—à—å - –ª—é–¥–µ–π –Ω–∞—Å–º–µ—à–∏—à—å")

        edit_achievements = {
            (1, 3): None,
            (3, 5): "üï∞Ô∏è –ß–∏—Ç–µ—Ä: –ß–∞—Å–æ–≤—â–∏–∫ II —É—Ä–æ–≤–Ω—è",
            (5, float('inf')): "üï∞Ô∏è –ß–∏—Ç–µ—Ä: –ß–∞—Å–æ–≤—â–∏–∫ III —É—Ä–æ–≤–Ω—è"
        }

        if activity.edited:
            new_achievements.append("üïµÔ∏è‚ôÇÔ∏è –ß–∏—Ç–µ—Ä: –ß–∞—Å–æ–≤—â–∏–∫")
            for (min_edit, max_edit), achievement in edit_achievements.items():
                if min_edit <= activity.edit_count < max_edit and achievement:
                    new_achievements.append(achievement)

        if new_achievements:
            achievements_count = {}
            for ach in new_achievements:
                achievements_count[ach] = achievements_count.get(ach, 0) + 1

            formatted_achievements = [
                f"‚Ä¢ {ach} x{count}" if count > 1 else f"‚Ä¢ {ach}"
                for ach, count in achievements_count.items()
            ]

            achievements_to_create = [
                Achievement(
                    user_id=user_id,
                    username=username,
                    achievement_name=ach.split(
                        " ", 1)[1] if " " in ach else ach
                ) for ach in new_achievements
            ]
        else:
            achievements_to_create = []
            formatted_achievements = ["‚Ä¢ –ü–æ–∫–∞ –Ω–∏—á–µ–≥–æ üê±"]
        if achievements_to_create:
            await sync_to_async(
                Achievement.objects.bulk_create)(achievements_to_create)

        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
        formatted_achievements_text = "\n".join(formatted_achievements)
        await context.bot.send_message(
            chat_id=group_chat_id,
            text=(
                "üèÜ *–ù–æ–≤–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!*\n"
                f"–°–æ—Ç—Ä—É–¥–Ω–∏–∫: @{username}\n"
                f"–ó–∞—Å–ª—É–≥–∏:\n{formatted_achievements_text}\n"
                "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! üéâ"
            ),
            parse_mode="Markdown"
        )
        achievement_names = []
        for ach in new_achievements:
            if " " in ach:
                achievement_names.append(ach.split(" ", 1)[1])
            else:
                achievement_names.append(ach)
        return achievement_names

    except Exception as e:
        logging.error(
            f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –¥–ª—è {username}: {str(e)}\n"
            f"–î–µ—Ç–∞–ª–∏: {traceback.format_exc()}",
            exc_info=True
        )


async def get_chat_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.message.chat_id
    try:
        chat = await context.bot.get_chat(chat_id)
        try:
            member_count = await chat.get_member_count()
        except Exception:
            member_count = (
                "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ (–≥—Ä—É–ø–ø–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è –∏–ª–∏ –±–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞)")
        chat_info = f"""
üîç –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —á–∞—Ç–µ:
- ID: {chat.id}
- –ù–∞–∑–≤–∞–Ω–∏–µ: {chat.title}
- –¢–∏–ø: {chat.type}
- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {member_count}
- –û–ø–∏—Å–∞–Ω–∏–µ: {chat.description if chat.description else "–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è"}
- –°—Å—ã–ª–∫–∞: {chat.invite_link if chat.invite_link else "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞"}
        """
        await update.message.reply_text(chat_info)
    except Exception as e:
        await update.message.reply_text(
            f"üö® *–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —á–∞—Ç–µ:* {e}",
            parse_mode="Markdown")


async def get_weather():
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–≥–æ–¥—ã —Å HTML-—Ä–∞–∑–º–µ—Ç–∫–æ–π."""
    api_key = os.getenv("OPENWEATHER_API_KEY")
    city = "Zelenograd"
    city_ru = "–ó–µ–ª–µ–Ω–æ–≥—Ä–∞–¥–µ"
    url = ("http://api.openweathermap.org/data/2.5/"
           + f"weather?q={city}&appid={api_key}&units=metric&lang=ru")

    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()
            if data["cod"] == 200:
                temp = data["main"]["temp"]
                feels_like = data["main"]["feels_like"]
                pressure_hpa = data["main"]["pressure"]
                pressure_mmhg = pressure_hpa * 0.750062

                if pressure_mmhg < 740:
                    pressure_status = "–Ω–∏–∑–∫–æ–µ"
                elif pressure_mmhg > 780:
                    pressure_status = "–≤—ã—Å–æ–∫–æ–µ"
                else:
                    pressure_status = "–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ"

                humidity = data["main"]["humidity"]
                description = data["weather"][0]["description"]
                clouds = data["clouds"]["all"]
                wind_speed = data["wind"]["speed"]
                wind_gust = data["wind"].get("gust", 0)
                wind_deg = data["wind"].get("deg", 0)

                def get_wind_direction(deg):
                    directions = [
                        "—Å–µ–≤–µ—Ä–Ω—ã–π", "—Å–µ–≤–µ—Ä–æ-–≤–æ—Å—Ç–æ—á–Ω—ã–π", "–≤–æ—Å—Ç–æ—á–Ω—ã–π",
                        "—é–≥–æ-–≤–æ—Å—Ç–æ—á–Ω—ã–π", "—é–∂–Ω—ã–π", "—é–≥–æ-–∑–∞–ø–∞–¥–Ω—ã–π",
                        "–∑–∞–ø–∞–¥–Ω—ã–π", "—Å–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥–Ω—ã–π"
                    ]
                    index = round((deg % 360) / 45) % 8
                    return directions[index]

                wind_direction = get_wind_direction(wind_deg)

                sunrise = datetime.fromtimestamp(
                    data["sys"]["sunrise"]).strftime("%H:%M")
                sunset = datetime.fromtimestamp(
                    data["sys"]["sunset"]).strftime("%H:%M")

                weather_emoji = {
                    "–¥–æ–∂–¥—å": "üåßÔ∏è",
                    "–Ω–µ–±–æ–ª—å—à–æ–π –¥–æ–∂–¥—å": "üåßÔ∏è",
                    "—Å–Ω–µ–≥": "‚ùÑÔ∏è",
                    "—Å–∏–ª—å–Ω—ã–π —Å–Ω–µ–≥–æ–ø–∞–¥": "üå®Ô∏è",
                    "–Ω–µ–±–æ–ª—å—à–æ–π —Å–Ω–µ–≥": "üå®Ô∏è",
                    "—è—Å–Ω–æ": "‚òÄÔ∏è",
                    "–æ–±–ª–∞—á–Ω–æ": "‚òÅÔ∏è",
                    "–ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å": "‚òÅÔ∏è",
                    "–Ω–µ–±–æ–ª—å—à–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å": "‚õÖ",
                    "–æ–±–ª–∞—á–Ω–æ —Å –ø—Ä–æ—è—Å–Ω–µ–Ω–∏—è–º–∏": "‚õÖ",
                    "–ø–∞—Å–º—É—Ä–Ω–æ": "üå•Ô∏è",
                    "–Ω–µ–±–æ–ª—å—à–∞—è –º–æ—Ä–æ—Å—å": "üåßÔ∏è",
                    "–ø–ª–æ—Ç–Ω—ã–π —Ç—É–º–∞–Ω": "üå´Ô∏è",
                    "—Ç—É–º–∞–Ω": "üå´Ô∏è",
                    "–≥—Ä–æ–∑–∞": "‚õàÔ∏è",
                    "–≤–µ—Ç–µ—Ä": "üí®",
                }

                emoji = weather_emoji.get(description.lower(), "‚ùì")

                forecast_url = ("http://api.openweathermap.org/data/2.5/"
                                + f"forecast?q={city}&appid={api_key}&"
                                + "units=metric&lang=ru")
                async with session.get(forecast_url) as forecast_response:
                    forecast_data = await forecast_response.json()
                    if forecast_data["cod"] == "200":
                        current_date = datetime.now().date()
                        morning_temp = morning_desc = None
                        day_temp = day_desc = None
                        evening_temp = evening_desc = None

                        for entry in forecast_data["list"]:
                            entry_time = datetime.fromtimestamp(entry["dt"])
                            if entry_time.date() == current_date:
                                time = entry_time.strftime("%H:%M")
                                weather_desc = entry[
                                    "weather"][0]["description"]
                                if time == "09:00":
                                    morning_temp = entry["main"]["temp"]
                                    morning_desc = weather_desc
                                elif time == "15:00":
                                    day_temp = entry["main"]["temp"]
                                    day_desc = weather_desc
                                elif time == "21:00":
                                    evening_temp = entry["main"]["temp"]
                                    evening_desc = weather_desc

                        forecast_html_lines = []
                        for time_name, temp_val, desc in [
                            ("–£—Ç—Ä–æ–º", morning_temp, morning_desc),
                            ("–î–Ω—ë–º", day_temp, day_desc),
                            ("–í–µ—á–µ—Ä–æ–º", evening_temp, evening_desc)
                        ]:
                            if temp_val is not None and desc is not None:
                                emoji_forecast = weather_emoji.get(
                                    desc.lower(), "‚ùì")
                                forecast_html_lines.append(
                                    f"<b>{emoji_forecast} {time_name}:</b>"
                                    + f" {temp_val}¬∞C ({desc})"
                                )
                            else:
                                forecast_html_lines.append(
                                    f"<b>‚ùì {time_name}:</b> –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")

                        forecast_temp_html = "\n".join(forecast_html_lines)

                        weather_message = (
                            f"<b>üèôÔ∏è –ü–æ–≥–æ–¥–∞ –≤ {city_ru}:</b> "
                            + f"{emoji} {description.capitalize()}\n\n"
                            f"<b>üå° –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:</b>\n"
                            f"- –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {temp}¬∞C\n"
                            f"- –û—â—É—â–∞–µ—Ç—Å—è –∫–∞–∫: {feels_like}¬∞C\n"
                            f"- –û–±–ª–∞—á–Ω–æ—Å—Ç—å: {clouds}%\n"
                            f"- –í–µ—Ç–µ—Ä: {wind_speed} –º/—Å, {wind_direction}\n"
                            f"- –ü–æ—Ä—ã–≤—ã: {wind_gust} –º/—Å\n"
                            f"- –î–∞–≤–ª–µ–Ω–∏–µ: {pressure_mmhg:.1f} –º–º —Ä—Ç.—Å—Ç."
                            + f" ({pressure_status})\n"
                            f"- –í–ª–∞–∂–Ω–æ—Å—Ç—å: {humidity}%\n\n"
                            f"<b>‚è≥ –î–ª–∏–Ω–∞ –¥–Ω—è –≤ {city_ru}:</b>\n"
                            f"- üåÖ –í–æ—Å—Ö–æ–¥: {sunrise}\n"
                            f"- üåá –ó–∞–∫–∞—Ç: {sunset}\n\n"
                            f"<b>üîÆ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:</b>\n"
                            f"{forecast_temp_html}\n\n"
                            f"<i>–ü–æ –¥–∞–Ω–Ω—ã–º openweathermap.org</i>"
                        )
                        return weather_message


async def send_weather_to_group(bot):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–≥–æ–¥—ã –≤ –≥—Ä—É–ø–ø—É —Å HTML-—Ä–∞–∑–º–µ—Ç–∫–æ–π."""
    try:
        weather_message = await get_weather()
        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")

        await bot.send_message(
            chat_id=group_chat_id,
            text=weather_message,
            parse_mode="HTML"
        )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–æ–≥–æ–¥—ã: {e}")
        await bot.send_message(
            chat_id=group_chat_id,
            text="üö® –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–≥–æ–¥—É. üö®",
            parse_mode="HTML"
        )


async def stop_scheduler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞."""
    if scheduler.running:
        scheduler.shutdown(wait=False)
        await update.message.reply_text("üõë –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø–æ–≥–æ–¥—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. üåßÔ∏è")
    else:
        await update.message.reply_text("üö¶ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. üö¶")


async def get_similar_companies(company_name):
    """
    Searches for companies with names similar to the given company_name
    and returns a list of the closest matches (up to 2 matches with a
    similarity cutoff of 0.6).

    :param company_name: The company name to search for.
    :return: A list of strings of the closest company name matches.
    """
    similar_companies = await sync_to_async(list)(
        Company.objects.filter(name__icontains=company_name).values_list(
            "name", flat=True)
    )
    return get_close_matches(company_name, similar_companies, n=2, cutoff=0.6)


async def join(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.from_user.id
    username = update.message.from_user.username
    company_name = " ".join(context.args)

    if not company_name:
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /join.",
            parse_mode="Markdown")
        return ConversationHandler.END

    if not VALID_COMPANY_NAME_PATTERN.match(company_name):
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ"
            + " –±—É–∫–≤—ã —Ä—É—Å—Å–∫–æ–≥–æ –∏–ª–∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞, —Ü–∏—Ñ—Ä—ã –∏ —Ç–∏—Ä–µ.",
            parse_mode="Markdown")
        return ConversationHandler.END

    active_activity = await sync_to_async(UserActivity.objects.filter(
        user_id=user_id, leave_time__isnull=True).exists)()

    if active_activity:
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—ã –µ—â—ë –Ω–µ –ø–æ–∫–∏–Ω—É–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.",
            parse_mode="Markdown")
        return ConversationHandler.END

    try:
        company = await sync_to_async(
            Company.objects.filter(name=company_name).first)()
        if company:
            local_time = timezone.localtime(timezone.now())
            await update.message.reply_text(
                f"üê±‚Äçüíª *–í—ã –ø—Ä–∏–±—ã–ª–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é `{company_name}`* üê±‚Äçüíª\n"
                f"‚è≥ –í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è: {local_time.strftime('%H:%M')}.",
                parse_mode="Markdown"
            )
            await sync_to_async(UserActivity.objects.create)(
                user_id=user_id,
                username=username,
                company=company
            )

            today = timezone.now().date()
            total_today = await sync_to_async(
                UserActivity.objects.filter(join_time__date=today).count
            )()
            if total_today == 1:
                achievement = Achievement(
                    user_id=user_id,
                    username=username,
                    achievement_name="ü©∏ –ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å"
                )
                await sync_to_async(achievement.save)()
                group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
                await context.bot.send_message(
                    chat_id=group_chat_id,
                    text=(
                        "üèÜ *–ù–æ–≤–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!*\n"
                        f"–°–æ—Ç—Ä—É–¥–Ω–∏–∫: @{username}\n"
                        f"–ó–∞—Å–ª—É–≥–∏: ü©∏ –ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å!\n"
                        "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! üéâ"
                    ),
                    parse_mode="Markdown"
                )

            return ConversationHandler.END
        else:
            similar_companies = await get_similar_companies(company_name)
            if similar_companies:
                similar_companies_text = "\n".join(
                    [f"{i + 1}. {company}" for i, company in enumerate(
                        similar_companies)])
                reply_keyboard = [
                    [KeyboardButton(company)] for company in similar_companies
                ] + [[KeyboardButton("–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é")]]
                await update.message.reply_text(
                    f"üö® *–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º \"{company_name}\" "
                    + "–Ω–µ –Ω–∞–π–¥–µ–Ω–æ.* üö®\n"
                    f"–í–æ–∑–º–æ–∂–Ω–æ, –≤—ã –∏–º–µ–ª–∏ –≤ –≤–∏–¥—É:\n{similar_companies_text}\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –Ω–æ–≤—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.",
                    parse_mode="Markdown",
                    reply_markup=ReplyKeyboardMarkup(
                        reply_keyboard, one_time_keyboard=True)
                )
                return SELECT_CO
            else:
                company, created = await sync_to_async(
                    Company.objects.get_or_create)(name=company_name)
                local_time = timezone.localtime(timezone.now())
                await update.message.reply_text(
                    f"üê±‚Äçüíª *–í—ã –ø—Ä–∏–±—ã–ª–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é {company_name}* üê±‚Äçüíª\n"
                    f"–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è: {local_time.strftime('%H:%M')}.",
                    parse_mode="Markdown"
                )
                await sync_to_async(UserActivity.objects.create)(
                    user_id=user_id,
                    username=username,
                    company=company
                )

                today = timezone.now().date()
                total_today = await sync_to_async(
                    UserActivity.objects.filter(join_time__date=today).count
                )()
                if total_today == 1:
                    achievement = Achievement(
                        user_id=user_id,
                        username=username,
                        achievement_name="ü©∏ –ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å"
                    )
                    await sync_to_async(achievement.save)()
                    group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
                    await context.bot.send_message(
                        chat_id=group_chat_id,
                        text=(
                            "üèÜ *–ù–æ–≤–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ!*\n"
                            f"–°–æ—Ç—Ä—É–¥–Ω–∏–∫: @{username}\n"
                            f"–ó–∞—Å–ª—É–≥–∏: ü©∏ –ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å!\n"
                            "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! üéâ"
                        ),
                        parse_mode="Markdown"
                    )

                return ConversationHandler.END
    except Exception:
        await update.message.reply_text(
            "üö® *–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.* üö®",
            parse_mode="Markdown"
        )
        return ConversationHandler.END


async def select_company(
        update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Callback –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.

    –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –≤—ã–±—Ä–∞—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö
    –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é
    –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é, —Ç–æ –æ–Ω –±—É–¥–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ –Ω–µ–π, –∏–Ω–∞—á–µ
    –æ–Ω –±—É–¥–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.

    :param update: update –æ—Ç Telegram
    :param context: context –æ—Ç Telegram
    :return: —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥ –≤ ConversationHandler
    """
    user_id = update.message.from_user.id
    username = update.message.from_user.username
    selected_company = update.message.text

    if not VALID_COMPANY_NAME_PATTERN.match(selected_company):
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ"
            + " –±—É–∫–≤—ã —Ä—É—Å—Å–∫–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞ –∏ —Ü–∏—Ñ—Ä—ã.",
            parse_mode="Markdown")
        return ConversationHandler.END

    if selected_company == "–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é":
        await update.message.reply_text(
            "üêæ *–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.* üêæ"
        )
        return JOIN_CO

    active_activity = await sync_to_async(UserActivity.objects.filter(
        user_id=user_id, leave_time__isnull=True).exists)()

    if active_activity:
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—ã –µ—â—ë –Ω–µ –ø–æ–∫–∏–Ω—É–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.",
            parse_mode="Markdown")
        return ConversationHandler.END

    company, created = await sync_to_async(
        Company.objects.get_or_create)(name=selected_company)
    local_time = timezone.localtime(timezone.now())
    await update.message.reply_text(
        f"üê±‚Äçüíª *–í—ã –ø—Ä–∏–±—ã–ª–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é {selected_company}* üê±‚Äçüíª\n"
        f"–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è: {local_time.strftime('%H:%M')}.",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardRemove()
    )
    await sync_to_async(UserActivity.objects.create)(
        user_id=user_id,
        username=username,
        company=company
    )
    return ConversationHandler.END


async def _validate_and_update_time(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    time_field: str,
    error_message_prefix: str,
    success_message: str,
) -> None:
    """
    –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏.
    """
    user_id = update.message.from_user.id

    active_activity = await sync_to_async(
        UserActivity.objects.filter(
            user_id=user_id,
            leave_time__isnull=True
        ).select_related('company').first
    )()

    if not active_activity:
        msg = await update.message.reply_text(
            f"üö® *–û—à–∏–±–∫–∞!* üö®\n"
            f"–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏, –¥–ª—è "
            f"–∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å {error_message_prefix}.",
            parse_mode="Markdown"
        )
        return False, msg

    args = context.args
    if not args or len(args) != 1:
        msg = await update.message.reply_text(
            f"üö® *–û—à–∏–±–∫–∞!* üö®\n"
            f"‚≠ïÔ∏è *–í–Ω–∏–º–∞–Ω–∏–µ! –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤–≤–æ–¥–∞*\n\n"
            f"üïí –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ {error_message_prefix} "
            f"–≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ *–ß–ß:–ú–ú*\n"
            f"–ü—Ä–∏–º–µ—Ä: *14:30*\n\n"
            f"üìñ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ "
            f"–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /help",
            parse_mode="Markdown"
        )
        return False, msg

    try:
        new_time = datetime.strptime(args[0], '%H:%M').time()
    except ValueError:
        msg = await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, "
            "—É–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ *–ß–ß:–ú–ú* (–Ω–∞–ø—Ä–∏–º–µ—Ä, 09:15).",
            parse_mode="Markdown"
        )
        return False, msg

    current_time = timezone.localtime(timezone.now()).time()
    if new_time > current_time:
        msg = await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –≤—ã–±—Ä–∞—Ç—å –≤—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ. "
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ —Ç–µ–∫—É—â–µ–º—É.",
            parse_mode="Markdown"
        )
        return False, msg

    current_tz = timezone.get_current_timezone()
    now = timezone.localtime(timezone.now())
    new_datetime = datetime.combine(now.date(),
                                    new_time,
                                    tzinfo=current_tz
                                    ).astimezone(dt_timezone.utc)

    if time_field == "leave_time" and new_datetime < active_activity.join_time:
        msg = await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—Ä–µ–º—è —É–±—ã—Ç–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–∏–±—ã—Ç–∏—è. "
            "–í–∞—à–µ –≤—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è: "
            f"{active_activity.join_time.strftime('%H:%M')}.",
            parse_mode="Markdown"
        )
        return False, msg

    if (time_field == "join_time"
        and active_activity.leave_time
            and new_datetime > active_activity.leave_time):
        msg = await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–∑–∂–µ –≤—Ä–µ–º–µ–Ω–∏ —É–±—ã—Ç–∏—è. "
            "–í–∞—à–µ –≤—Ä–µ–º—è —É–±—ã—Ç–∏—è: "
            f"{active_activity.leave_time.strftime('%H:%M')}.",
            parse_mode="Markdown"
        )
        return False, msg

    setattr(active_activity, time_field, new_datetime)
    active_activity.edited = True
    active_activity.edit_count += 1
    await sync_to_async(active_activity.save)()

    company_name = active_activity.company.name
    local_time = timezone.localtime(new_datetime).strftime('%H:%M')

    msg = await update.message.reply_text(
        f"üòª *–£—Å–ø–µ—à–Ω–æ!* üòª\n"
        f"{success_message.format(
            company_name=company_name, time=local_time)}.",
        parse_mode="Markdown"
    )
    return True, msg


async def edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –£—Å—Ç–∞—Ä–µ–≤—à–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏.
    –ò–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –Ω–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥–∞—Ö.
    """
    message = BotMessages.EDIT_MSG
    await update.message.reply_text(message, parse_mode="Markdown")


async def edit_arrival_time(update: Update,
                            context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–∏–±—ã—Ç–∏—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.
    """
    await _validate_and_update_time(
        update,
        context,
        time_field="join_time",
        error_message_prefix="–≤—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è",
        success_message=("–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é {company_name} "
                         "—É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {time}"),
    )

    user_id = update.message.from_user.id
    username = update.message.from_user.username
    await update_daily_statistics(user_id, username)


async def edit_departure_time(update: Update,
                              context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.message.from_user.id
    username = update.message.from_user.username

    success, _ = await _validate_and_update_time(
        update,
        context,
        time_field="leave_time",
        error_message_prefix="–≤—Ä–µ–º—è —É–±—ã—Ç–∏—è",
        success_message=("–í—Ä–µ–º—è —É–±—ã—Ç–∏—è –∏–∑ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ {company_name} "
                         "—É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {time}"),
    )

    if success:
        try:
            activity = await sync_to_async(
                UserActivity.objects.select_related("company").filter(
                    user_id=user_id,
                    leave_time__isnull=False).latest)("leave_time")

            if activity:
                achievements_list = await check_achievements(user_id, username,
                                                             activity, context)
                today = timezone.now().date()
                daily_visits_count = await sync_to_async(
                    UserActivity.objects.filter(
                        user_id=user_id,
                        join_time__date=today
                    ).count)()
                exp_earned = calculate_experience(activity, achievements_list,
                                                  daily_visits_count)
                time_spent = activity.leave_time - activity.join_time
                rank, level_up, new_level = await update_season_rank(
                    user_id, exp_earned, time_spent, username)

                company_name = activity.company.name
                spent_time = activity.get_spent_time

                message = (
                    f"‚åõ *–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –ø–æ—Å–µ—â–µ–Ω–∏–∏* ‚åõ\n"
                    f"üè≠ –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è: *{company_name}*\n"
                    f"‚è≥ –ù–æ–≤–æ–µ –∑–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è: {spent_time}.",
                    f"üî∞ –ü–æ–ª—É—á–µ–Ω–æ –æ–ø—ã—Ç–∞: {exp_earned}",
                )
                if level_up:
                    level_info = await get_level_info(rank)
                    message += (
                        "\n\nüéâ *–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–≤—ã—à–µ–Ω–∏–µ–º —É—Ä–æ–≤–Ω—è!* üéâ\n"
                        f"üèÜ –ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å: *{new_level} lvl - "
                        f"{level_info['title']}*\n"
                        f"üìö –ö–∞—Ç–µ–≥–æ—Ä–∏—è: *{level_info['category']}*"
                    )

                await update.message.reply_text(message, parse_mode="Markdown")
            else:
                logging.warning(
                    f"–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
                await update.message.reply_text(
                    "‚ö†Ô∏è *–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:* "
                    + "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –æ –ø–æ—Å–µ—â–µ–Ω–∏–∏.",
                    parse_mode="Markdown"
                )

        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã /edit_end: {e}")
            await update.message.reply_text(
                "üö® *–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã.* üö®",
                parse_mode="Markdown"
            )


async def add_new_company(
        update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Callback –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.

    –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –≤–≤–µ—Å—Ç–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏,
    –∏ –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Ç–æ –æ–Ω–∞ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∞,
    –∏–Ω–∞—á–µ - –±—É–¥–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é
    –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.

    :param update: update –æ—Ç Telegram
    :param context: context –æ—Ç Telegram
    :return: —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥ –≤ ConversationHandler
    """
    user_id = update.message.from_user.id
    username = update.message.from_user.username
    company_name = update.message.text

    active_activity = await sync_to_async(UserActivity.objects.filter(
        user_id=user_id, leave_time__isnull=True).exists)()

    if active_activity:
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—ã –µ—â—ë –Ω–µ –ø–æ–∫–∏–Ω—É–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é.",
            parse_mode="Markdown")
        return ConversationHandler.END

    if not VALID_COMPANY_NAME_PATTERN.match(company_name):
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ"
            + " –±—É–∫–≤—ã —Ä—É—Å—Å–∫–æ–≥–æ –∏–ª–∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞ –∏ —Ü–∏—Ñ—Ä—ã",
            parse_mode="Markdown")
        return ConversationHandler.END
    local_time = timezone.localtime(timezone.now())
    company, created = await sync_to_async(
        Company.objects.get_or_create)(name=company_name)
    await update.message.reply_text(
        f"üê±‚Äçüíª *–í—ã –ø—Ä–∏–±—ã–ª–∏ –∫ –Ω–æ–≤–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ {company_name}* üê±‚Äçüíª\n"
        f"–í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è: {local_time.strftime('%H:%M')}.\n ",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardRemove()
    )
    await sync_to_async(UserActivity.objects.create)(
        user_id=user_id,
        username=username,
        company=company
    )
    return ConversationHandler.END


async def leave(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Callback –¥–ª—è —É—Ö–æ–¥–∞ –∏–∑ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.

    –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø—Ä–∞–≤–∏—Ç –∫–æ–º–∞–Ω–¥—É /leave,
    —Ç–æ –æ–Ω –ø–æ–∫–∏–Ω–µ—Ç –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é, –∫ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω
    –ø—Ä–∏–±—ã–ª, –∏ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–æ –∑–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è.

    :param update: update –æ—Ç Telegram
    :param context: context –æ—Ç Telegram
    :return: None
    """

    user_id = update.message.from_user.id
    username = update.message.from_user.username
    try:
        activity = await sync_to_async(UserActivity.objects.select_related(
            "company").filter(
                user_id=user_id,
                leave_time__isnull=True).latest)("join_time")
        achievements_list = await check_achievements(user_id, username,
                                                     activity, context)
        today = timezone.now().date()
        daily_visits_count = await sync_to_async(UserActivity.objects.filter(
            user_id=user_id,
            join_time__date=today,
        ).count)()
        activity.leave_time = timezone.now()
        exp_earned = calculate_experience(activity, achievements_list,
                                          daily_visits_count)
        time_spent = activity.leave_time - activity.join_time
        rank, level_up, new_level = await update_season_rank(
            user_id, exp_earned, time_spent, username)
        await sync_to_async(activity.save)()

        await update_daily_statistics(user_id, username)

        company_name = activity.company.name
        spent_time = activity.get_spent_time
        local_time = timezone.localtime(timezone.now())

        message = (
            f"üêæüëã *–í—ã –ø–æ–∫–∏–Ω—É–ª–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é {company_name}* üêæüëã\n"
            f"‚åõÔ∏è –í—Ä–µ–º—è —É—Ö–æ–¥–∞: {local_time.strftime('%H:%M')}.\n"
            f"‚è≥ –ó–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è: {spent_time}.\n"
            f"üî∞ –ü–æ–ª—É—á–µ–Ω–æ –æ–ø—ã—Ç–∞: {exp_earned}"
        )

        if level_up:
            level_info = await get_level_info(rank)
            message += (
                "\n\nüéâ *–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–≤—ã—à–µ–Ω–∏–µ–º —É—Ä–æ–≤–Ω—è!* üéâ\n"
                f"üèÜ –ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å: *{new_level} lvl - {level_info['title']}*\n"
                f"üìö –ö–∞—Ç–µ–≥–æ—Ä–∏—è: *{level_info['category']}*"
            )
        await update.message.reply_text(message, parse_mode="Markdown")

    except UserActivity.DoesNotExist:
        await update.message.reply_text(
            "‚ùå *–û—à–∏–±–∫–∞!* ‚ùå\n"
            "–í—ã –Ω–µ –ø—Ä–∏–±—ã–ª–∏ –Ω–∏ –∫ –æ–¥–Ω–æ–π –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏.", parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã /leave: {e}")
        await update.message.reply_text(
            "üö® *–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞.* üö®",
            parse_mode="Markdown")


async def remind_to_leave(bot):
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    –≤–≤–µ—Å—Ç–∏ –∫–æ–º–∞–Ω–¥—É /leave."""
    try:
        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
        if not group_chat_id:
            logging.error("TELEGRAM_GROUP_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env")
            return
        active_activities = await sync_to_async(
            lambda: list(UserActivity.objects.filter(leave_time__isnull=True))
        )()

        if not active_activities:
            return

        users = []
        for activity in active_activities:
            username = (
                f"@{activity.username}"
                if activity.username
                else f"ID: {activity.user_id}")
            company_name = await sync_to_async(lambda: activity.company.name)()
            users.append(f"{username} ({company_name})")
        message = (
            "‚ö†Ô∏è *–í–Ω–∏–º–∞–Ω–∏–µ!* ‚ö†Ô∏è\n\n"
            "–°–ª–µ–¥—É—é—â–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ –≤—Å—ë –µ—â—ë –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö:\n"
            f"{'\n'.join(users)}\n\n"
            "üõ†Ô∏è *–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å?*\n"
            "1. –ï—Å–ª–∏ –≤—ã —É–∂–µ –ø–æ–∫–∏–Ω—É–ª–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é ‚Äî "
            "*–ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä—É–π—Ç–µ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ*.\n"
            "2. –ï—Å–ª–∏ –µ—â—ë –Ω–µ —É—à–ª–∏ ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\n\n"

            "üìç *–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*\n"
            "‚Ä¢ /edit\\_start <–ß–ß:–ú–ú> ‚Äî —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è "
            "(–ø—Ä–∏–º–µ—Ä: /edit\\_start 09:30)\n"
            "‚Ä¢ /edit\\_end <–ß–ß:–ú–ú> ‚Äî –∏–∑–º–µ–Ω–∏—Ç—å –≤—Ä–µ–º—è —É–±—ã—Ç–∏—è –∏ "
            "–∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é (–ø—Ä–∏–º–µ—Ä: /edit\\_end 18:15)"""
            "–ö–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ leave\n\n"

            "‚ùó *–í–∞–∂–Ω–æ:*\n"
            "‚Äî –†–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è *–∞–∫—Ç–∏–≤–Ω—ã—Ö* —Å–µ—Å—Å–∏–π "
            "(–≥–¥–µ –≤—ã —Å–µ–π—á–∞—Å —á–∏—Å–ª–∏—Ç–µ—Å—å –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ)\n"
            "‚Äî –§–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏: 09:00, 14:30 (24-—á–∞—Å–æ–≤–æ–π)"
        )
        try:
            await bot.send_message(
                chat_id=group_chat_id,
                text=message,
                parse_mode="Markdown",
                disable_notification=False)
            logging.info(f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –≥—Ä—É–ø–ø—É {group_chat_id}")
        except telegram.error.BadRequest as e:
            logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –≥—Ä—É–ø–ø—É: {e.message}")
            if "chat not found" in str(e).lower():
                logging.critical(
                    "–ë–æ—Ç –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä—É–ø–ø—É –∏–ª–∏ chat_id –Ω–µ–≤–µ—Ä–Ω—ã–π!")
        except telegram.error.Forbidden as e:
            logging.error(f"–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É: {e.message}")
            if "bot was blocked" in str(e).lower():
                logging.critical("–ë–æ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –≤ –≥—Ä—É–ø–ø–µ!")
        except Exception as e:
            logging.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)

    except Exception as e:
        logging.error(
            f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ remind_to_leave: {e}", exc_info=True)


async def check_and_send_transport_reminder(bot):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–∞—Ö –∑–∞ –º–µ—Å—è—Ü."""
    try:
        today = timezone.now().date()
        if today.month == 12:
            last_day = today.replace(
                year=today.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            last_day = today.replace(
                month=today.month + 1, day=1) - timedelta(days=1)

        days_left = (last_day - today).days

        if days_left in [7, 4, 2]:
            group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
            if not group_chat_id:
                logging.error("TELEGRAM_GROUP_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env")
                return
            messages = [
                (f"‚è∞ *–í–∞–∂–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ!* –î–æ –∫–æ–Ω—Ü–∞ –º–µ—Å—è—Ü–∞ {days_left} –¥–Ω–µ–π\n"
                 "üöñ –ü–æ—Ä–∞ –≤–Ω–µ—Å—Ç–∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –∏ –¥–∞–Ω–Ω—ã–µ –æ –ø—Ä–æ–µ–∑–¥–Ω—ã—Ö!"),
                (f"üìÖ –í–Ω–∏–º–∞–Ω–∏–µ! –û—Å—Ç–∞–ª–æ—Å—å {days_left} –¥–Ω–µ–π –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –º–µ—Å—è—Ü–∞\n"
                 "üöï –ù–µ –∑–∞–±—É–¥—å—Ç–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã–µ –∑–∞—Ç—Ä–∞—Ç—ã!"),
                (f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {days_left} –¥–Ω—è –¥–æ –∫–æ–Ω—Ü–∞ –º–µ—Å—è—Ü–∞\n"
                 "üöô –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —É—á–µ—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç!")
            ]
            await bot.send_message(
                chat_id=group_chat_id,
                text=random.choice(messages),
                parse_mode="Markdown"
            )
    except telegram.error.BadRequest as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}")
    except Exception as e:
        logging.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}", exc_info=True)


async def mew(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —Ñ–æ—Ç–æ –∫–æ—Ç–∏–∫–∞."""
    url = "https://api.thecatapi.com/v1/images/search"

    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    cat_photo_url = data[0]["url"]
                    await update.message.reply_photo(photo=cat_photo_url)
                else:
                    await update.message.reply_text(
                        "üòø –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ç–æ –∫–æ—Ç–∏–∫–∞. üòø")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ API –∫–æ—Ç–∏–∫–æ–≤: {e}")
            await update.message.reply_text(
                "üòø –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–æ—Ç–æ –∫–æ—Ç–∏–∫–∞. üòø")


async def send_daily_statistics_to_group(bot):
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    –∑–∞—Ä–∞–Ω–µ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≥—Ä—É–ø–ø–µ.

    –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ–∫–∞–µ—Ç –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤
    –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç, —É–∫–∞–∑–∞–Ω–Ω—ã–π –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Ä–µ–¥—ã TELEGRAM_GROUP_CHAT_ID.
    –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown.

    :param bot: –≠–∫–∑–µ–º–ø–ª—è—Ä Telegram-–±–æ—Ç–∞, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è.
    """
    try:
        tz = pytz.timezone("Europe/Moscow")
        now = datetime.now(tz)
        today_date = now.date()
        any_trips_today = await has_any_trips_on_date(today_date)

        if not any_trips_today:
            logging.info(f"–ü—Ä–æ–ø—É—Å–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ {today_date} - –Ω–µ—Ç –≤—ã–µ–∑–¥–æ–≤.")
            return
        stats = await get_daily_statistics()
        if stats["total_trips"] <= 0 and stats["total_time"].total_seconds() <= 0:
            logging.info(
                f"–ü—Ä–æ–ø—É—Å–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ {today_date} - –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.")
            return
        # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ, —Ñ–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        message = await get_daily_statistics_message()
        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
        if not group_chat_id:
            logging.error("TELEGRAM_GROUP_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env")
            return
        await bot.send_message(chat_id=group_chat_id,
                               text=message,
                               parse_mode="Markdown")
        logging.info(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ {today_date} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}", exc_info=True)


async def get_current_season():
    try:
        return await sync_to_async(Season.objects.get)(is_active=True)
    except Season.DoesNotExist:
        return None


async def update_season_rank(user_id: int,
                             exp_earned: int,
                             time_spent: timedelta,
                             username: str):
    season = await get_current_season()
    if not season:
        return None, False, 0

    rank, created = await sync_to_async(SeasonRank.objects.get_or_create)(
        user_id=user_id,
        season=season,
        defaults={
            "username": username,
            "experience": exp_earned,
            "total_time": time_spent,
            "visits_count": 1
        }
    )
    old_level = rank.level
    level_up = False
    if not created:
        rank.experience += exp_earned
        rank.total_time += time_spent
        rank.visits_count += 1

        while rank.experience >= rank.level * 100:
            rank.experience -= rank.level * 100
            rank.level += 1
            level_up = True
        if level_up:
            try:
                new_level_title = await sync_to_async(
                    LevelTitle.objects.get)(level=rank.level)
                rank.level_title = new_level_title
            except LevelTitle.DoesNotExist:
                pass

        await sync_to_async(rank.save)()

    new_level = rank.level if level_up else old_level

    return rank, level_up, new_level


async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.message.from_user.id

    try:
        season = await get_current_season()
        if not season:
            await update.message.reply_text(
                "‚ÑπÔ∏è –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Å–µ–∑–æ–Ω –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. "
                "–û–∂–∏–¥–∞–π—Ç–µ –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ —Å–µ–∑–æ–Ω–∞!",
                parse_mode="Markdown"
            )
            return

        rank = await sync_to_async(
            SeasonRank.objects.select_related("level_title")
            .get
        )(user_id=user_id, season=season)

        level_info = await get_level_info(rank)

        total_hours = int(rank.total_time.total_seconds() // 3600)
        total_minutes = int((rank.total_time.total_seconds() % 3600) // 60)
        time_str = f"{total_hours}—á {total_minutes}–º"

        now = timezone.now().date()
        days_left = (season.end_date - now).days

        progress_bar = create_progress_bar(level_info["progress"])

        message = (
            f"üèÜ *–¢–µ–∫—É—â–∏–π —Å–µ–∑–æ–Ω: {season.name}*\n"
            f"‚è≥ –î–æ –∫–æ–Ω—Ü–∞ —Å–µ–∑–æ–Ω–∞: *{days_left} –¥–Ω–µ–π*\n\n"
            "üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å*\n\n"
            f"üéØ –£—Ä–æ–≤–µ–Ω—å: *{rank.level}*\n"
            f"üéñ –ó–≤–∞–Ω–∏–µ: *{level_info['title']}*\n"
            f"üìö –ö–∞—Ç–µ–≥–æ—Ä–∏—è: *{level_info['category']}*\n"
            f"‚≠ê –û–ø—ã—Ç: *{level_info['current_exp']}/"
            f"{level_info['next_level_exp']}*\n"
            f"üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: {progress_bar} {int(level_info['progress'])}%\n"
            f"‚è± –í—Å–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö: *{time_str}*\n"
            f"üöó –í—Å–µ–≥–æ –≤—ã–µ–∑–¥–æ–≤: *{rank.visits_count}*\n\n"
            f"{season.get_theme_display()} –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è! "
            "–£—Å–ø–µ–π—Ç–µ –¥–æ—Å—Ç–∏—á—å –Ω–æ–≤—ã—Ö –≤—ã—Å–æ—Ç!"
        )
    except SeasonRank.DoesNotExist:
        message = (
            "üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å*\n\n"
            "–í—ã –µ—â—ë –Ω–µ —Å–æ–≤–µ—Ä—à–∞–ª–∏ –≤—ã–µ–∑–¥–æ–≤ –≤ —Ç–µ–∫—É—â–µ–º —Å–µ–∑–æ–Ω–µ.\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /join —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!")
    await update.message.reply_text(message, parse_mode="Markdown")


async def start_weather(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å–∫ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–≥–æ–¥—ã –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è"""
    if not context.args:
        await update.message.reply_text(
            "‚ùå –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä: /start_weather 9:30)"
        )
        return

    time_str = context.args[0]
    try:
        hour, minute = map(int, time_str.split(":"))
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
        return

    if not (0 <= hour <= 23 and 0 <= minute <= 59):
        await update.message.reply_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—Ä–µ–º—è")
        return

    try:
        scheduler.remove_job("weather_job")
    except JobLookupError:
        pass

    scheduler.add_job(
        send_weather_to_group,
        trigger="cron",
        hour=hour,
        minute=minute,
        args=[context.bot],
        id="weather_job"
    )

    if not scheduler.running:
        scheduler.start()

    await update.message.reply_text(
        f"‚õÖ –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–≥–æ–¥—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ {hour:02}:{minute:02}"
    )


async def start_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å–∫ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    if not context.args:
        await update.message.reply_text(
            "‚ùå –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä: /start_stats 20:00)"
        )
        return

    time_str = context.args[0]
    try:
        hour, minute = map(int, time_str.split(':'))
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
        return

    if not (0 <= hour <= 23 and 0 <= minute <= 59):
        await update.message.reply_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—Ä–µ–º—è")
        return

    try:
        scheduler.remove_job("stats_job")
    except JobLookupError:
        pass

    scheduler.add_job(
        send_daily_statistics_to_group,
        trigger="cron",
        hour=hour,
        minute=minute,
        args=[context.bot],
        id="stats_job"
    )

    if not scheduler.running:
        scheduler.start()

    await update.message.reply_text(
        f"üìä –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ "
        f"—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ {hour:02}:{minute:02}"
    )


async def start_reminder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–æ–∫–∏–Ω—É—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é"""
    if not context.args:
        await update.message.reply_text(
            "‚ùå –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä: /start_reminder 19:45)"
        )
        return

    time_str = context.args[0]
    try:
        hour, minute = map(int, time_str.split(':'))
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
        return

    if not (0 <= hour <= 23 and 0 <= minute <= 59):
        await update.message.reply_text("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –≤—Ä–µ–º—è")
        return

    for job_id in ["reminder_job", "transport_reminder"]:
        try:
            scheduler.remove_job(job_id)
        except JobLookupError:
            pass

    scheduler.add_job(
        remind_to_leave,
        trigger="cron",
        hour=hour,
        minute=minute,
        args=[context.bot],
        id="reminder_job"
    )

    scheduler.add_job(
        check_and_send_transport_reminder,
        trigger="cron",
        hour=9,
        minute=0,
        args=[context.bot],
        id="transport_reminder",
        timezone=ZoneInfo("Europe/Moscow"))

    if not scheduler.running:
        scheduler.start()

    response_message = (
        "üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã:\n\n"
        "‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö ‚Äî "
        f"–µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ {hour:02}:{minute:02}\n"
        "‚Ä¢ –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã ‚Äî –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 09:00 "
        "(—Ç–æ–ª—å–∫–æ –∑–∞ 7/4/1 –¥–Ω–µ–π –¥–æ –∫–æ–Ω—Ü–∞ –º–µ—Å—è—Ü–∞)"
    )

    await update.message.reply_text(response_message)


async def send_daily_tip(bot):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ —Å–æ–≤–µ—Ç–∞"""
    try:
        unpublished_tip = await sync_to_async(DailytTips.objects.filter(
            is_published=False
        ).order_by("pub_date").first)()

        if unpublished_tip:
            tip = unpublished_tip
            tip.is_published = True
            tip.pub_date = timezone.now()
            await sync_to_async(tip.save)()
            message_prefix = "üåü *–ù–æ–≤—ã–π —Å–æ–≤–µ—Ç –¥–Ω—è!*\n\n"
        else:
            tip = await sync_to_async(DailytTips.objects.filter(
                is_published=True
            ).order_by("?").first)()
            message_prefix = "üîÅ *–õ—É—á—à–∏–µ —Å–æ–≤–µ—Ç—ã*\n\n"

        if not tip:
            logging.warning("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
            return

        max_preview_length = 50
        content_preview = tip.content[:max_preview_length].rstrip()
        if len(tip.content) > max_preview_length:
            content_preview += "..."
        site_base_url = os.getenv("SITE_URL")
        tip_detail_url = f"{site_base_url}/tips/{tip.id}/"

        message = (
            f"{message_prefix}"
            f"üìå *{tip.title}*\n\n"
            f"{content_preview}\n\n"
        )
        message += f"üëÅ‚Äçüó® –ü—Ä–æ—Å–º–æ—Ç—Ä–æ–≤: {tip.views_count}\n\n"

        tags = await sync_to_async(list)(tip.tags.all())
        if tags:
            tag_list = " ".join(
                [f"#{tag.slug.replace('-', r'\_')}" for tag in tags])
            message += f"üè∑ *–¢–µ–≥–∏:* {tag_list}\n\n"
        message += f"üîó [–ß–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é]({tip_detail_url})\n\n"
        if tip.external_link:
            message += f"‚ÑπÔ∏è [–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]({tip.external_link})"

        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
        await bot.send_message(
            chat_id=group_chat_id,
            text=message,
            parse_mode="Markdown",
            disable_web_page_preview=True
        )

        tip.views_count += 1
        await sync_to_async(tip.save)()

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–≤–µ—Ç–∞: {str(e)}", exc_info=True)


async def start_dailytips(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å–∫ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–≤–µ—Ç–æ–≤ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è"""
    if not context.args:
        await update.message.reply_text(
            "‚ùå –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú "
            "(–Ω–∞–ø—Ä–∏–º–µ—Ä: /start_dailytips 10:00)"
        )
        return

    try:
        hour, minute = map(int, context.args[0].split(':'))
        if not (0 <= hour <= 23 and 0 <= minute <= 59):
            raise ValueError
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
        return

    try:
        scheduler.remove_job("dailytips_job")
    except JobLookupError:
        pass

    scheduler.add_job(
        send_daily_tip,
        trigger='cron',
        hour=hour,
        minute=minute,
        args=[context.bot],
        id="dailytips_job",
        timezone=ZoneInfo("Europe/Moscow")
    )

    if not scheduler.running:
        scheduler.start()

    await update.message.reply_text(
        f"‚úÖ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å—Å—è –≤ {hour:02}:{minute:02}\n"
        "–õ–æ–≥–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:\n"
        "1. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —É –Ω–µ–æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤\n"
        "2. –ï—Å–ª–∏ –≤—Å–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã - —Å–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä"
    )


async def stop_dailytips(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤"""
    try:
        scheduler.remove_job("dailytips_job")
        await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–≤–µ—Ç–æ–≤ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    except JobLookupError:
        await update.message.reply_text("‚ö†Ô∏è –ê–∫—Ç–∏–≤–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")


async def handle_unknown_command(update: Update,
                                 context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
    (—Å–æ–æ–±—â–µ–Ω–∏–π, –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö—Å—è —Å /)"""
    try:
        message = update.message
        command = message.text.split()[0].lower()

        if not command.startswith("/"):
            return

        if command.lstrip("/") in BotMessages.AVAILABLE_COMMANDS:
            return

        user_input = command.lstrip("/")
        matches = get_close_matches(user_input,
                                    BotMessages.AVAILABLE_COMMANDS,
                                    n=1, cutoff=0.4)

        if matches:
            suggestion = f"/{matches[0]}"
            reply_text = (
                f"üîç *–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞* `{command}`\n\n"
                f"–í–æ–∑–º–æ–∂–Ω–æ –≤—ã –∏–º–µ–ª–∏ –≤ –≤–∏–¥—É: {suggestion}?\n\n"
                "üìù –î–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help"
            )
        else:
            reply_text = (
                f"‚ùå *–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞* `{command}`\n\n"
                "üìù –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥"
            )

        await message.reply_text(
            reply_text,
            parse_mode="Markdown",
            reply_markup=ReplyKeyboardRemove()
        )

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã: {str(e)}", exc_info=True)


async def active_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤, –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.
    """
    try:
        active_activities = await sync_to_async(list)(
            UserActivity.objects.select_related("company")
            .filter(leave_time__isnull=True)
        )

        if not active_activities:
            await update.message.reply_text(
                "‚ÑπÔ∏è *–°—Ç–∞—Ç—É—Å:* –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–∏–∫—Ç–æ "
                "–Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö.",
                parse_mode="Markdown"
            )
            return

        companies = {}
        tz = ZoneInfo("Europe/Moscow")

        for activity in active_activities:
            company_name = activity.company.name
            join_time = activity.join_time.astimezone(tz).strftime("%H:%M")

            username = (f"@{activity.username}"
                        if activity.username
                        else f"ID:{activity.user_id}")

            if company_name not in companies:
                companies[company_name] = []
            companies[company_name].append((username, join_time))

        message_lines = ["üöÄ *–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è—Ö:*\n"]
        for company, users in companies.items():
            message_lines.append(f"\nüè¢ *{company}*:")
            for i, (username, join_time) in enumerate(users, 1):
                message_lines.append(f"{i}. {username} - –ø—Ä–∏–±—ã–ª –≤ {join_time}")

        message = "\n".join(message_lines)
        await update.message.reply_text(message, parse_mode="Markdown")

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã /status: {e}")
        await update.message.reply_text(
            "üö® –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤",
            parse_mode="Markdown"
        )


async def send_currency_rates_to_group(bot):
    try:
        rates = await fetch_currency_rates()
        await save_currency_rates(rates)
        changes = await get_currency_changes()
        message_lines = ["*üí± –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç:*", ""]
        fiat_currencies = {
            "USD": "üá∫üá∏ *USD/RUB*",
            "EUR": "üá™üá∫ *EUR/RUB*",
            "CNY": "üá®üá≥ *CNY/RUB*"
        }
        crypto_currencies = {
            "BTC_USD": "‚Çø *BTC/USD*",
            "BTC_RUB": "‚Çø *BTC/RUB*"
        }
        message_lines.append("*üìå –§–∏–∞—Ç–Ω—ã–µ –≤–∞–ª—é—Ç—ã:*")
        for code, name in fiat_currencies.items():
            if code in changes:
                data = changes[code]
                trend = "üìà" if data["change"] > 0 else ("üìâ" if data["change"] < 0 else "üìä")
                change_sign = "+" if data["change"] > 0 else ""
                message_lines.append(
                    f"{name}: *{data['current']:.2f}* {trend} "
                    f"(`{change_sign}{data['change']:.2f}` / "
                    f"`{change_sign}{data['percent']:.2f}%`)"
                )
            else:
                last_rate = await sync_to_async(
                    CurrencyRate.objects.filter(
                        currency=code
                    ).order_by("-date").first
                )()
                if last_rate:
                    message_lines.append(
                        f"{name}: *{last_rate.rate:.2f}* `(–¥–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞)`"
                    )
        message_lines.append("") 
        message_lines.append("*‚ö° –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã:*")
        for code, name in crypto_currencies.items():
            if code in changes:
                data = changes[code]
                trend = "üìà" if data["change"] > 0 else ("üìâ" if data["change"] < 0 else "üìä")
                change_sign = "+" if data["change"] > 0 else ""
                message_lines.append(
                    f"{name}: *{data['current']:.2f}* {trend} "
                    f"(`{change_sign}{data['change']:.2f}` / "
                    f"`{change_sign}{data['percent']:.2f}%`)"
                )
            else:
                last_rate = await sync_to_async(
                    CurrencyRate.objects.filter(
                        currency=code
                    ).order_by("-date").first
                )()
                if last_rate:
                    message_lines.append(
                        f"{name}: *{last_rate.rate:.2f}* `(–¥–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞)`"
                    )
        timestamp = datetime.now().strftime("%d.%m.%Y %H:%M")
        message_lines.append(f"\n*üïí –û–±–Ω–æ–≤–ª–µ–Ω–æ:* `{timestamp}`")
        group_chat_id = os.getenv("TELEGRAM_GROUP_CHAT_ID")
        await bot.send_message(
            chat_id=group_chat_id,
            text="\n".join(message_lines),
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫—É—Ä—Å–æ–≤: {e}")


async def start_currency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–ø—É—Å–∫ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫—É—Ä—Å–æ–≤ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è"""
    if not context.args:
        await update.message.reply_text(
            "‚ùå –£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä: /start_currency 8:00)"
        )
        return

    time_str = context.args[0]
    try:
        hour, minute = map(int, time_str.split(':'))
        if not (0 <= hour <= 23 and 0 <= minute <= 59):
            raise ValueError
    except ValueError:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
        return

    try:
        scheduler.remove_job("currency_job")
    except JobLookupError:
        pass

    scheduler.add_job(
        send_currency_rates_to_group,
        trigger="cron",
        hour=hour,
        minute=minute,
        args=[context.bot],
        id="currency_job",
        timezone=ZoneInfo("Europe/Moscow")
    )

    if not scheduler.running:
        scheduler.start()

    await update.message.reply_text(
        f"üí± –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫—É—Ä—Å–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ {hour:02}:{minute:02}\n"
        "–ö—É—Ä—Å –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ —ç—Ç–æ –≤—Ä–µ–º—è"
    )


async def stop_currency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Ä–∞—Å—Å—ã–ª–∫–∏ –∫—É—Ä—Å–æ–≤"""
    try:
        scheduler.remove_job("currency_job")
        await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∫—É—Ä—Å–æ–≤ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    except JobLookupError:
        await update.message.reply_text("‚ö†Ô∏è –ê–∫—Ç–∏–≤–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")


class Command(BaseCommand):
    help = "–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –¢–µ–ª–µ–≥—Ä–∞–º–º"

    def handle(self, *args, **options):
        application = get_bot_application()

        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler("join", join),
            ],
            states={
                SELECT_CO: [MessageHandler(
                    filters.TEXT & ~filters.COMMAND, select_company)],
                JOIN_CO: [MessageHandler(
                    filters.TEXT & ~filters.COMMAND, add_new_company)],
            },
            fallbacks=[CommandHandler(
                "cancel", lambda update, context: ConversationHandler.END)],
        )

        application.add_handler(conv_handler)
        application.add_handler(CommandHandler("help", help))
        application.add_handler(CommandHandler("site", site))
        application.add_handler(CommandHandler("get_chat_info", get_chat_info))
        application.add_handler(CommandHandler("leave", leave))
        application.add_handler(CommandHandler("mew", mew))
        application.add_handler(CommandHandler("start_weather", start_weather))
        application.add_handler(CommandHandler("start_stats", start_stats))
        application.add_handler(CommandHandler("profile", profile))
        application.add_handler(
            CommandHandler("start_reminder", start_reminder))
        application.add_handler(CommandHandler(
            "stop_scheduler", stop_scheduler))
        application.add_handler(CommandHandler("edit", edit))
        application.add_handler(
            CommandHandler("edit_start", edit_arrival_time))
        application.add_handler(
            CommandHandler("edit_end", edit_departure_time))
        application.add_handler(CommandHandler(
            "start_dailytips", start_dailytips))
        application.add_handler(CommandHandler(
            "stop_dailytips", stop_dailytips))
        application.add_handler(CommandHandler("status", active_users))
        application.add_handler(CommandHandler(
            "start_currency", start_currency))
        application.add_handler(CommandHandler(
            "stop_currency", stop_currency))
        application.add_handler(
            MessageHandler(filters.COMMAND, handle_unknown_command)
        )

        try:
            logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ polling...")
            application.run_polling(allowed_updates=Update.ALL_TYPES)
        except KeyboardInterrupt:
            logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            self.stdout.write(self.style.SUCCESS("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."))
            application.stop()
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ –±–æ—Ç–∞: {e}")
